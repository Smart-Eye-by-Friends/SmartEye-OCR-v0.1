# DB 파일 경로 저장 방식의 문제점 및 해결 방안

## 1. 현상 및 문제점 진단

현재 SmartEye 시스템은 업로드된 파일 및 분석 과정에서 생성된 결과물의 **절대 경로(Absolute Path)**를 데이터베이스에 직접 저장하고 있습니다.

`FileUtils.java`의 `saveUploadedFile` 메서드는 다음과 같이 구현되어 있습니다.

```java
// ...
Path filePath = uploadPath.resolve(uniqueFilename);
Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
// ...
return filePath.toString(); // 예: "/home/user/project/uploads/image_20250930.png"
```

이 방식은 현재 개발 환경에서는 정상 동작하는 것처럼 보이지만, 다음과 같은 심각한 문제점을 내포하고 있어 배포 및 운영 단계에서 반드시 장애를 발생시킵니다.

### 주요 문제점

#### 가. 환경 종속성 및 이식성 부재
- **문제:** 데이터베이스에 저장된 절대 경로는 특정 장비의 특정 디렉토리 구조에 강하게 종속됩니다.
- **영향:**
    - **배포 환경 이전 불가:** 현재 개발 환경(`/home/jongyoung3/...`)과 실제 프로덕션 서버 환경(`/var/www/app/` 등)의 경로는 다르므로, 배포 시 모든 파일 관련 기능이 실패합니다.
    - **Docker/Kubernetes 적용 불가:** 컨테이너 기반 환경에서는 내부의 격리된 파일 시스템을 사용하므로, 호스트의 절대 경로는 아무 의미가 없습니다.
    - **협업의 어려움:** 다른 팀원이 자신의 PC에서 프로젝트를 실행할 때마다 경로가 맞지 않아 오류가 발생합니다.

#### 나. 유지보수 및 확장성 저하
- **문제:** 파일 저장 정책이 변경될 때마다 모든 데이터와 코드를 수정해야 합니다.
- **영향:**
    - **저장소 변경의 어려움:** 향후 파일 저장 위치를 다른 디스크, NAS, 또는 클라우드 스토리지(AWS S3 등)로 변경할 경우, 데이터베이스에 있는 모든 경로 데이터를 마이그레이션해야 하는 거대한 작업이 필요합니다.
    - **수평 확장(Scale-out) 불가:** 여러 대의 서버로 시스템을 확장할 때, A서버에 저장된 파일의 절대 경로는 B서버에서 접근할 수 없으므로 부하 분산 아키텍처를 적용할 수 없습니다.

#### 다. 보안 취약점
- **문제:** 데이터베이스가 외부에 유출될 경우, 서버의 내부 파일 시스템 구조가 그대로 노출됩니다.
- **영향:** 공격자에게 시스템의 구조에 대한 불필요한 정보를 제공하여 추가적인 공격의 빌미를 줄 수 있습니다.

## 2. 해결 방안

핵심 해결 원칙은 **"환경에 따라 변하는 정보(베이스 경로)와 변하지 않는 정보(파일 식별자)를 분리"**하는 것입니다.

### 단계별 해결 전략

#### 1단계: 데이터베이스에는 상대 경로(Relative Path)만 저장

파일을 저장하는 로직(`FileUtils.java`)을 수정하여, 전체 절대 경로가 아닌 고유한 **파일명** 또는 **지정된 하위 경로를 포함한 상대 경로**만 반환하도록 변경합니다.

- **AS-IS:** `return filePath.toString();`
- **TO-BE:** `return uniqueFilename;`

이렇게 수정하면 데이터베이스에는 `image_20250930.png`와 같은 순수 파일명만 저장됩니다.

#### 2단계: 환경별 설정 파일에 베이스 경로(Base Path) 정의

파일이 실제로 저장될 루트 디렉토리의 절대 경로는 `application.properties` 또는 `application.yml`에 정의합니다. Spring Profile을 활용하여 각 환경별로 다른 경로를 지정할 수 있습니다.

**`application-dev.properties` (개발 환경)**
```properties
smarteye.upload.dir=/home/jongyoung3/SmartEye_v0.4/uploads
```

**`application-prod.properties` (프로덕션 환경)**
```properties
smarteye.upload.dir=/var/data/smarteye_uploads
```

#### 3단계: 런타임(Runtime)에 절대 경로 동적 조합

애플리케이션 코드에서 파일에 접근해야 할 때, **(2단계)설정 파일의 베이스 경로**와 **(1단계)DB의 상대 경로**를 동적으로 조합하여 완전한 절대 경로를 만들어 사용합니다.

이러한 경로 조합 로직은 `FileService`와 같은 특정 서비스 클래스에 중앙화하여 관리하는 것이 바람직합니다.

**`FileService.java` 예시**
```java
@Service
public class FileService {

    private final Path uploadBasePath;

    // 생성자에서 설정 파일의 베이스 경로를 주입받아 Path 객체로 보관
    @Autowired
    public FileService(SmartEyeProperties properties) {
        this.uploadBasePath = Paths.get(properties.getUpload().getDirectory()).toAbsolutePath().normalize();
    }

    /**
     * DB에 저장된 상대 경로를 이용해 전체 절대 경로를 반환
     * @param relativePath DB에 저장된 파일의 상대 경로 (예: "image_20250930.png")
     * @return 파일 시스템에서 접근 가능한 절대 경로 Path 객체
     */
    public Path getAbsolutePath(String relativePath) {
        if (relativePath == null || relativePath.isBlank()) {
            throw new IllegalArgumentException("상대 경로는 null이거나 비어있을 수 없습니다.");
        }
        
        Path resolvedPath = this.uploadBasePath.resolve(relativePath).normalize();

        // **보안 강화**: 조합된 경로가 베이스 경로를 벗어나지 않는지 검증
        if (!resolvedPath.startsWith(this.uploadBasePath)) {
            throw new FileProcessingException("잘못된 파일 경로 접근 시도: " + relativePath);
        }

        return resolvedPath;
    }

    // 파일을 읽거나 쓸 때 이 메서드를 통해 경로를 얻음
    public File readFile(String relativePath) throws IOException {
        Path absolutePath = getAbsolutePath(relativePath);
        if (!Files.exists(absolutePath)) {
            throw new FileNotFoundException("파일을 찾을 수 없습니다: " + absolutePath.toString());
        }
        return absolutePath.toFile();
    }
}
```

## 3. 기대 효과

위 해결 방안을 적용하면 다음과 같은 효과를 얻을 수 있습니다.

- **이식성 확보:** 서버 환경이 변경되어도 `application.properties`의 베이스 경로만 수정하면 되므로, 코드 변경 없이 시스템을 어떤 환경으로든 쉽게 이전할 수 있습니다.
- **유지보수성 향상:** 파일 저장소 위치를 변경하는 작업이 설정 파일 수정만으로 끝나므로 매우 간단해집니다.
- **확장성 증대:** 향후 로드 밸런싱 환경이나 클라우드 스토리지(S3 등)로 전환할 때, 경로 처리 로직을 `FileService`에서만 수정하면 되므로 유연하게 대처할 수 있습니다.
- **보안 강화:** 데이터베이스에는 상대 경로만 존재하므로, DB가 유출되어도 서버의 전체 파일 구조가 노출되지 않습니다.
